{
  "language": "Solidity",
  "sources": {
    "contracts/Gm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {IBaseERC721Interface, ConfigSettings} from \"gwei-slim-nft-contracts/contracts/base/ERC721Base.sol\";\nimport {ERC721Delegated} from \"gwei-slim-nft-contracts/contracts/base/ERC721Delegated.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {GmRenderer} from \"./GmRenderer.sol\";\nimport {Base64} from \"base64-sol/base64.sol\";\n\n/**\n                                                    \n        GGGGGGGGGGGGGMMMMMMMM               MMMMMMMM\n     GGG::::::::::::GM:::::::M             M:::::::M\n   GG:::::::::::::::GM::::::::M           M::::::::M\n  G:::::GGGGGGGG::::GM:::::::::M         M:::::::::M\n G:::::G       GGGGGGM::::::::::M       M::::::::::M\nG:::::G              M:::::::::::M     M:::::::::::M\nG:::::G              M:::::::M::::M   M::::M:::::::M\nG:::::G    GGGGGGGGGGM::::::M M::::M M::::M M::::::M\nG:::::G    G::::::::GM::::::M  M::::M::::M  M::::::M\nG:::::G    GGGGG::::GM::::::M   M:::::::M   M::::::M\nG:::::G        G::::GM::::::M    M:::::M    M::::::M\n G:::::G       G::::GM::::::M     MMMMM     M::::::M\n  G:::::GGGGGGGG::::GM::::::M               M::::::M\n   GG:::::::::::::::GM::::::M               M::::::M\n     GGG::::::GGG:::GM::::::M               M::::::M\n        GGGGGG   GGGGMMMMMMMM               MMMMMMMM\n                                                    \n */\ncontract Gm is ERC721Delegated {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    CountersUpgradeable.Counter private currentTokenId;\n    uint256 public immutable maxSupply;\n    uint256 public salePrice;\n    GmRenderer public renderer;\n    mapping(uint256 => bytes32) private mintSeeds;\n    mapping(uint256 => bool) private hasHadCoffee;\n    event DrankCoffee(uint256 indexed tokenId, address indexed actor);\n\n    constructor(\n        address baseFactory,\n        address _rendererAddress,\n        uint256 _maxSupply\n    )\n        ERC721Delegated(\n            baseFactory,\n            \"gm\",\n            \"gm\",\n            ConfigSettings({\n                royaltyBps: 1000,\n                uriBase: \"\",\n                uriExtension: \"\",\n                hasTransferHook: false\n            })\n        )\n    {\n        renderer = GmRenderer(_rendererAddress);\n        maxSupply = _maxSupply;\n    }\n\n    function drinkCoffee(uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Needs to own\");\n        require(!hasHadCoffee[tokenId], \"Already had coffee\");\n        mintSeeds[tokenId] = _generateSeed(tokenId);\n        emit DrankCoffee(tokenId, msg.sender);\n    }\n\n    // price = 0 == sale not started\n    function setSalePrice(uint256 newPrice) public onlyOwner {\n        salePrice = newPrice;\n    }\n\n    function mintsLeft() external view returns (uint256) {\n        return maxSupply - currentTokenId.current();\n    }\n\n    function mint(uint256 count) public payable {\n        require(currentTokenId.current() + count <= maxSupply, \"Gm: sold out\");\n        require(salePrice != 0, \"Gm: sale not started\");\n        require(count <= 10, \"Gm: cannot mint more than 10 in one transaction\");\n        require(msg.value == salePrice * count, \"Gm: wrong sale price\");\n\n        for (uint256 i = 0; i < count; i++) {\n            mintSeeds[currentTokenId.current()] = _generateSeed(\n                currentTokenId.current()\n            );\n            _mint(msg.sender, currentTokenId.current());\n            currentTokenId.increment();\n        }\n    }\n\n    function burn(uint256 tokenId) public {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"Gm: only approved or owner can burn\"\n        );\n        _burn(tokenId);\n    }\n\n    /**\n      @dev This withdraws ETH from the contract to the contract owner.\n     */\n    function withdraw() external onlyOwner {\n        // No need for gas limit to trusted address.\n        AddressUpgradeable.sendValue(payable(_owner()), address(this).balance);\n    }\n\n    function svgBase64Data(bytes memory data)\n        internal\n        pure\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:image/svg+xml;base64,\",\n                    Base64.encode(data)\n                )\n            );\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        string memory json;\n        (bytes memory tokenData, bytes memory name, bytes memory bgColor, bytes memory fontColor, bytes memory filter) = renderer.svgRaw(\n            mintSeeds[tokenId]\n        );\n\n        bytes memory caff;\n        if (hasHadCoffee[tokenId]) {\n            caff = \"Yes\";\n        } else {\n            caff = \"No\";\n        }\n\n        bytes memory attributes = abi.encodePacked('\"attributes\": [',\n            '{\"trait_type\":\"style\",\"value\":\"',\n            name,\n            '\"},{\"trait_type\":\"background color\",\"value\":\"',\n            bgColor,\n            '\"},{\"trait_type\":\"font color\",\"value\":\"',\n            fontColor,\n            '\"},{\"trait_type\":\"caffeinated\",\"value\":\"',\n            caff,\n            '\"},{\"trait_type\":\"effect\",\"value\":\"',\n            filter,\n            '\"}]');\n\n        json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"description\": \"gm-onchain is a collection of 6969 randomly generated, onchain renderings of our favorite crypto phrase. enjoy.\",',\n                        '\"title\": \"gm ',\n                        StringsUpgradeable.toString(tokenId),\n                        '\", \"image\": \"',\n                        svgBase64Data(tokenData),\n                        '\",',\n                        attributes,\n                        '}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    function seed(uint256 tokenId) external view returns (bytes32) {\n        return mintSeeds[tokenId];\n    }\n\n    function _generateSeed(uint256 tokenId) private view returns (bytes32) {\n        return\n            keccak256(abi.encodePacked(\n                            msg.sender,\n                            tx.gasprice,\n                            tokenId,\n                            block.number,\n                            block.timestamp,\n                            blockhash(block.number - 1)\n                    )\n            );\n    }\n}\n"
    },
    "gwei-slim-nft-contracts/contracts/base/ERC721Base.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {IERC2981Upgradeable, IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {IBaseERC721Interface} from \"./IBaseERC721Interface.sol\";\n\nstruct ConfigSettings {\n    uint16 royaltyBps;\n    string uriBase;\n    string uriExtension;\n    bool hasTransferHook;\n}\n\n/**\n    This smart contract adds features and allows for a ownership only by another smart contract as fallback behavior\n    while also implementing all normal ERC721 functions as expected\n*/\ncontract ERC721Base is\n    ERC721Upgradeable,\n    IBaseERC721Interface,\n    IERC2981Upgradeable,\n    OwnableUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    // Minted counter for totalSupply()\n    CountersUpgradeable.Counter private mintedCounter;\n\n    modifier onlyInternal() {\n        require(msg.sender == address(this), \"Only internal\");\n        _;\n    }\n\n    /// on-chain record of when this contract was deployed\n    uint256 public immutable deployedBlock;\n\n    ConfigSettings public advancedConfig;\n\n    /// Constructor called once when the base contract is deployed\n    constructor() {\n        // Can be used to verify contract implementation is correct at address\n        deployedBlock = block.number;\n    }\n\n    /// Initializer that's called when a new child nft is setup\n    /// @param newOwner Owner for the new derived nft\n    /// @param _name name of NFT contract\n    /// @param _symbol symbol of NFT contract\n    /// @param settings configuration settings for uri, royalty, and hooks features\n    function initialize(\n        address newOwner,\n        string memory _name,\n        string memory _symbol,\n        ConfigSettings memory settings\n    ) public initializer {\n        __ERC721_init(_name, _symbol);\n        __Ownable_init();\n\n        advancedConfig = settings;\n\n        transferOwnership(newOwner);\n    }\n\n    /// Getter to expose appoval status to root contract\n    function isApprovedForAll(address _owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            ERC721Upgradeable.isApprovedForAll(_owner, operator) ||\n            operator == address(this);\n    }\n\n    /// internal getter for approval by all\n    /// When isApprovedForAll is overridden, this can be used to call original impl\n    function __isApprovedForAll(address _owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isApprovedForAll(_owner, operator);\n    }\n\n    /// Hook that when enabled manually calls _beforeTokenTransfer on\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (advancedConfig.hasTransferHook) {\n            (bool success, ) = address(this).delegatecall(\n                abi.encodeWithSignature(\n                    \"_beforeTokenTransfer(address,address,uint256)\",\n                    from,\n                    to,\n                    tokenId\n                )\n            );\n            // Raise error again from result if error exists\n            assembly {\n                switch success\n                // delegatecall returns 0 on error.\n                case 0 {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /// Internal-only function to update the base uri\n    function __setBaseURI(string memory uriBase, string memory uriExtension)\n        public\n        override\n        onlyInternal\n    {\n        advancedConfig.uriBase = uriBase;\n        advancedConfig.uriExtension = uriExtension;\n    }\n\n    /// @dev returns the number of minted tokens\n    /// uses some extra gas but makes etherscan and users happy so :shrug:\n    /// partial erc721enumerable implemntation\n    function totalSupply() public view returns (uint256) {\n        return mintedCounter.current();\n    }\n\n    /**\n      Internal-only\n      @param to address to send the newly minted NFT to\n      @dev This mints one edition to the given address by an allowed minter on the edition instance.\n     */\n    function __mint(address to, uint256 tokenId)\n        external\n        override\n        onlyInternal\n    {\n        _mint(to, tokenId);\n        mintedCounter.increment();\n    }\n\n    /**\n        @param tokenId Token ID to burn\n        User burn function for token id \n     */\n    function burn(uint256 tokenId) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not allowed\");\n        _burn(tokenId);\n        mintedCounter.decrement();\n    }\n\n    /// Internal only\n    function __burn(uint256 tokenId) public onlyInternal {\n        _burn(tokenId);\n        mintedCounter.decrement();\n    }\n\n    /**\n        Simple override for owner interface.\n     */\n    function owner()\n        public\n        view\n        override(OwnableUpgradeable)\n        returns (address)\n    {\n        return super.owner();\n    }\n\n    /// internal alias for overrides\n    function __owner()\n        public\n        view\n        override(IBaseERC721Interface)\n        returns (address)\n    {\n        return owner();\n    }\n\n    /// Get royalty information for token\n    /// ignored token id to get royalty info. able to override and set per-token royalties\n    /// @param _salePrice sales price for token to determine royalty split\n    function royaltyInfo(uint256, uint256 _salePrice)\n        external\n        view\n        override\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        // If ownership is revoked, don't set royalties.\n        if (owner() == address(0x0)) {\n            return (owner(), 0);\n        }\n        return (owner(), (_salePrice * advancedConfig.royaltyBps) / 10_000);\n    }\n\n    /// Default simple token-uri implementation. works for ipfs folders too\n    /// @param tokenId token id ot get uri for\n    /// @return default uri getter functionality\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"No token\");\n\n        return\n            string(\n                abi.encodePacked(\n                    advancedConfig.uriBase,\n                    StringsUpgradeable.toString(tokenId),\n                    advancedConfig.uriExtension\n                )\n            );\n    }\n\n    /// internal base override\n    function __tokenURI(uint256 tokenId)\n        public\n        view\n        onlyInternal\n        returns (string memory)\n    {\n        return tokenURI(tokenId);\n    }\n\n    /// Exposing token exists check for base contract\n    function __exists(uint256 tokenId) external view override returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /// Getter for approved or owner\n    function __isApprovedOrOwner(address spender, uint256 tokenId)\n        external\n        view\n        override\n        onlyInternal\n        returns (bool)\n    {\n        return _isApprovedOrOwner(spender, tokenId);\n    }\n\n    /// IERC165 getter\n    /// @param interfaceId interfaceId bytes4 to check support for\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return\n            type(IERC2981Upgradeable).interfaceId == interfaceId ||\n            type(IBaseERC721Interface).interfaceId == interfaceId ||\n            ERC721Upgradeable.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "gwei-slim-nft-contracts/contracts/base/ERC721Delegated.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {StorageSlotUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\";\n\nimport {IBaseERC721Interface, ConfigSettings} from \"./ERC721Base.sol\";\n\ncontract ERC721Delegated {\n    uint256[100000] gap;\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    // Reference to base NFT implementation\n    function implementation() public view returns (address) {\n        return\n            StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    function _initImplementation(address _nftImplementation) private {\n        StorageSlotUpgradeable\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = _nftImplementation;\n    }\n\n    /// Constructor that sets up the\n    constructor(\n        address _nftImplementation,\n        string memory name,\n        string memory symbol,\n        ConfigSettings memory settings\n    ) {\n        /// Removed for gas saving reasons, the check below implictly accomplishes this\n        // require(\n        //     _nftImplementation.supportsInterface(\n        //         type(IBaseERC721Interface).interfaceId\n        //     )\n        // );\n        _initImplementation(_nftImplementation);\n        (bool success, ) = _nftImplementation.delegatecall(\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,(uint16,string,string,bool))\",\n                msg.sender,\n                name,\n                symbol,\n                settings\n            )\n        );\n        require(success);\n    }\n\n    /// OnlyOwner implemntation that proxies to base ownable contract for info\n    modifier onlyOwner() {\n        require(msg.sender == base().__owner(), \"Not owner\");\n        _;\n    }\n\n    /// Getter to return the base implementation contract to call methods from\n    /// Don't expose base contract to parent due to need to call private internal base functions\n    function base() private view returns (IBaseERC721Interface) {\n        return IBaseERC721Interface(address(this));\n    }\n\n    // helpers to mimic Openzeppelin internal functions\n\n    /// Getter for the contract owner\n    /// @return address owner address\n    function _owner() internal view returns (address) {\n        return base().__owner();\n    }\n\n    /// Internal burn function, only accessible from within contract\n    /// @param id nft id to burn\n    function _burn(uint256 id) internal {\n        base().__burn(id);\n    }\n\n    /// Internal mint function, only accessible from within contract\n    /// @param to address to mint NFT to\n    /// @param id nft id to mint\n    function _mint(address to, uint256 id) internal {\n        base().__mint(to, id);\n    }\n\n    /// Internal exists function to determine if fn exists\n    /// @param id nft id to check if exists\n    function _exists(uint256 id) internal view returns (bool) {\n        return base().__exists(id);\n    }\n\n    /// Internal getter for tokenURI\n    /// @param tokenId id of token to get tokenURI for\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\n        return base().__tokenURI(tokenId);\n    }\n\n    /// is approved for all getter underlying getter\n    /// @param owner to check\n    /// @param operator to check\n    function _isApprovedForAll(address owner, address operator)\n        internal\n        view\n        returns (bool)\n    {\n        return base().__isApprovedForAll(owner, operator);\n    }\n\n    /// Internal getter for approved or owner for a given operator\n    /// @param operator address of operator to check\n    /// @param id id of nft to check for\n    function _isApprovedOrOwner(address operator, uint256 id)\n        internal\n        view\n        returns (bool)\n    {\n        return base().__isApprovedOrOwner(operator, id);\n    }\n\n    /// Sets the base URI of the contract. Allowed only by parent contract\n    /// @param newUri new uri base (http://URI) followed by number string of nft followed by extension string\n    /// @param newExtension optional uri extension\n    function _setBaseURI(string memory newUri, string memory newExtension)\n        internal\n    {\n        base().__setBaseURI(newUri, newExtension);\n    }\n\n    /**\n     * @dev Delegates the current call to nftImplementation.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        address impl = implementation();\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev No base NFT functions receive any value\n     */\n    receive() external payable {\n        revert();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/GmRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {InflateLib} from \"./InflateLib.sol\";\nimport {GmDataInterface} from \"./GmDataInterface.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\ninterface ICorruptionsFont {\n    function font() external view returns (string memory);\n}\n\ncontract GmRenderer {\n    ICorruptionsFont private immutable font;\n    GmDataInterface private immutable gmData1;\n    GmDataInterface private immutable gmData2;\n\n    struct Color {\n        bytes hexNum;\n        bytes name;\n    }\n\n    constructor(\n        ICorruptionsFont fontAddress,\n        GmDataInterface gmData1Address,\n        GmDataInterface gmData2Address\n    ) {\n        font = fontAddress;\n        gmData1 = gmData1Address;\n        gmData2 = gmData2Address;\n    }\n\n    function decompress(GmDataInterface.GmDataSet memory gmData)\n        public\n        pure\n        returns (bytes memory, bytes memory)\n    {\n        (, bytes memory inflated) = InflateLib.puff(\n            gmData.compressedImage,\n            gmData.compressedSize\n        );\n        return (gmData.imageName, inflated);\n    }\n\n    function _getFilter(uint256 index) internal pure returns (bytes memory) {\n        // 0 || 99 2%\n        if (index == 0 || index == 99) {\n            return \"noise\";\n        }\n\n        // 1 || 2 || 3 || 4 || 5 5%\n        if (\n            (index == 1) ||\n            (index == 2) ||\n            (index == 3) ||\n            (index == 4) ||\n            (index == 5)\n        ) {\n            return \"lit\";\n        }\n\n        // 7 || 8 || 98 3%\n        if ((index == 7) || (index == 8) || (index == 9)) {\n            return \"scribble\";\n        }\n\n        // 10 - 29 -> morph 20%\n        if (((100 - index) > 70) && ((100 - index) <= 90)) {\n            return \"morph\";\n        }\n\n        // 30 - 39 -> glow 10%\n        if (((100 - index) > 60) && ((100 - index) <= 70)) {\n            return \"glow\";\n        }\n\n        // 69\n        if (index == 69) {\n            return \"fractal\";\n        }\n\n        return \"none\";\n    }\n\n    function _getColors(bytes32 seed)\n        internal\n        pure\n        returns (Color memory bgColor, Color memory fontColor)\n    {\n        uint32 bgRand = uint32(bytes4(seed)) % 111;\n        uint32 fontJitter = uint32(bytes4(seed << 32)) % 5;\n        uint32 fontOperation = uint8(bytes1(seed << 64)) % 2;\n        uint32 fontRand;\n        if (fontOperation == 0) {\n            fontRand = (bgRand + (55 + fontJitter)) % 111;\n        } else {\n            fontRand = (bgRand + (55 - fontJitter)) % 111;\n        }\n\n        return (_getColor(bgRand), _getColor(fontRand));\n    }\n\n    function strCompare(string memory a, string memory b) internal pure returns (bool) {\n        if(bytes(a).length != bytes(b).length) {\n            return false;\n        } else {\n            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n        }\n    }\n\n    function svgRaw(bytes32 seed)\n        external\n        view\n        returns (\n            bytes memory,\n            bytes memory,\n            bytes memory,\n            bytes memory,\n            bytes memory\n        )\n    {\n        // first 24 bytes used to construct hsl\n        //Hsl memory hsl = _getHsl(seed)\n        uint32 style = uint32(bytes4(seed << 65)) % 69;\n        uint32 filterRand = uint32(bytes4(seed << 97)) % 100;\n        bytes memory filter = _getFilter(filterRand);\n\n\n        (Color memory bgColor, Color memory fontColor) = _getColors(seed);\n\n        bytes memory inner;\n        bytes memory name;\n        if (style < 50) {\n            (name, inner) = decompress(gmData1.getSvg(style));\n        } else {\n            (name, inner) = decompress(gmData2.getSvg(style));\n        }\n\n        if ((strCompare(string(name), \"Hex\")) || (strCompare(string(name), \"Binary\")) || (strCompare(string(name), \"Morse\")) || (strCompare(string(name), \"Mnemonic\"))){\n            filter = \"none\";\n        }\n\n        return (\n            abi.encodePacked(\n                svgPreambleString(bgColor.hexNum, fontColor.hexNum, filter),\n                inner,\n                \"</svg>\"\n            ),\n            name,\n            bgColor.name,\n            fontColor.name,\n            filter\n        );\n    }\n\n    function svgFilterDefs() private view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                '<defs><filter id=\"fractal\" filterUnits=\"objectBoundingBox\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" ><feTurbulence id=\"turbulence\" type=\"fractalNoise\" baseFrequency=\"0.03\" numOctaves=\"1\" ><animate attributeName=\"baseFrequency\" values=\"0.01;0.4;0.01\" dur=\"100s\" repeatCount=\"indefinite\" /></feTurbulence><feDisplacementMap in=\"SourceGraphic\" scale=\"50\"></feDisplacementMap></filter><filter id=\"morph\"><feMorphology operator=\"dilate\" radius=\"0\"><animate attributeName=\"radius\" values=\"0;5;0\" dur=\"8s\" repeatCount=\"indefinite\" /></feMorphology></filter><filter id=\"glow\" filterUnits=\"objectBoundingBox\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" ><feGaussianBlur stdDeviation=\"5\" result=\"blur2\" in=\"SourceGraphic\" /><feMerge><feMergeNode in=\"blur2\" /><feMergeNode in=\"SourceGraphic\" /></feMerge></filter><filter id=\"noise\"><feTurbulence baseFrequency=\"0.05\"/><feColorMatrix type=\"hueRotate\" values=\"0\"><animate attributeName=\"values\" from=\"0\" to=\"360\" dur=\"1s\" repeatCount=\"indefinite\"/></feColorMatrix><feColorMatrix type=\"matrix\" values=\"0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0\"/><feDisplacementMap in=\"SourceGraphic\" scale=\"10\"/></filter><filter id=\"none\"><feOffset></feOffset></filter><filter id=\"scribble\"><feTurbulence type=\"turbulence\" baseFrequency=\"0.05\" numOctaves=\"2\" result=\"turbulence\"/><feDisplacementMap in2=\"turbulence\" in=\"SourceGraphic\" scale=\"50\" xChannelSelector=\"R\" yChannelSelector=\"G\"/></filter><filter id=\"tile\" x=\"10\" y=\"10\" width=\"10%\" height=\"10%\"><feTile in=\"SourceGraphic\" x=\"10\" y=\"10\" width=\"10\" height=\"10\" /><feTile/></filter><filter id = \"lit\" x=\"-30\" y=\"-30\" width=\"640\" height=\"640\"><feTurbulence type=\"turbulence\" baseFrequency=\"0.01\" numOctaves=\"2\" result=\"turbulence\"/><feComposite in=\"SourceGraphic\" in2=\"specOut\" operator=\"arithmetic\" k1=\"0\" k2=\"1\" k3=\"1\" k4=\"0\"/></filter></defs>'\n            );\n    }\n\n    function svgPreambleString(\n        bytes memory bgColor,\n        bytes memory fontColor,\n        bytes memory filter\n    ) private view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                \"<svg viewBox='0 0 640 640' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'><style> @font-face { font-family: CourierFont; src: url('\",\n                font.font(),\n                \"') format('opentype'); }\",\n                \".base{filter:url(#\",\n                filter,\n                \");fill:\",\n                fontColor,\n                \";font-family:CourierFont;font-size: 16px;}</style>\",\n                svgFilterDefs(),\n                '<rect width=\"100%\" height=\"100%\" fill=\"',\n                bgColor,\n                '\" /> '\n            );\n    }\n\n    function _getColor(uint32 index)\n        internal\n        pure\n        returns (Color memory color)\n    {\n        // AUTOGEN:START\n\n        if (index == 0) {\n            color.hexNum = \"#000000\";\n            color.name = \"Black\";\n        }\n\n        if (index == 1) {\n            color.hexNum = \"#004c6a\";\n            color.name = \"Navy Dark Blue\";\n        }\n\n        if (index == 2) {\n            color.hexNum = \"#0098d4\";\n            color.name = \"Bayern Blue\";\n        }\n\n        if (index == 3) {\n            color.hexNum = \"#00e436\";\n            color.name = \"Lexaloffle Green\";\n        }\n\n        if (index == 4) {\n            color.hexNum = \"#1034a6\";\n            color.name = \"Egyptian Blue\";\n        }\n\n        if (index == 5) {\n            color.hexNum = \"#008811\";\n            color.name = \"Lush Garden\";\n        }\n\n        if (index == 6) {\n            color.hexNum = \"#06d078\";\n            color.name = \"Underwater Fern\";\n        }\n\n        if (index == 7) {\n            color.hexNum = \"#1c1cf0\";\n            color.name = \"Bluebonnet\";\n        }\n\n        if (index == 8) {\n            color.hexNum = \"#127453\";\n            color.name = \"Green Velvet\";\n        }\n\n        if (index == 9) {\n            color.hexNum = \"#14bab4\";\n            color.name = \"Super Rare Jade\";\n        }\n\n        if (index == 10) {\n            color.hexNum = \"#111122\";\n            color.name = \"Corbeau\";\n        }\n\n        if (index == 11) {\n            color.hexNum = \"#165d95\";\n            color.name = \"Lapis Jewel\";\n        }\n\n        if (index == 12) {\n            color.hexNum = \"#16b8f3\";\n            color.name = \"Zima Blue\";\n        }\n\n        if (index == 13) {\n            color.hexNum = \"#1ef876\";\n            color.name = \"Synthetic Spearmint\";\n        }\n\n        if (index == 14) {\n            color.hexNum = \"#214fc6\";\n            color.name = \"New Car\";\n        }\n\n        if (index == 15) {\n            color.hexNum = \"#249148\";\n            color.name = \"Paperboy's Lawn\";\n        }\n\n        if (index == 16) {\n            color.hexNum = \"#24da91\";\n            color.name = \"Reptile Green\";\n        }\n\n        if (index == 17) {\n            color.hexNum = \"#223311\";\n            color.name = \"Darkest Forest\";\n        }\n\n        if (index == 18) {\n            color.hexNum = \"#297f6d\";\n            color.name = \"Mermaid Sea\";\n        }\n\n        if (index == 19) {\n            color.hexNum = \"#22cccc\";\n            color.name = \"Mermaid Net\";\n        }\n\n        if (index == 20) {\n            color.hexNum = \"#2e2249\";\n            color.name = \"Elderberry\";\n        }\n\n        if (index == 21) {\n            color.hexNum = \"#326ab1\";\n            color.name = \"Dover Straits\";\n        }\n\n        if (index == 22) {\n            color.hexNum = \"#2bc51b\";\n            color.name = \"Felwood Leaves\";\n        }\n\n        if (index == 23) {\n            color.hexNum = \"#391285\";\n            color.name = \"Pixie Powder\";\n        }\n\n        if (index == 24) {\n            color.hexNum = \"#2e58e8\";\n            color.name = \"Veteran's Day Blue\";\n        }\n\n        if (index == 25) {\n            color.hexNum = \"#419f59\";\n            color.name = \"Chateau Green\";\n        }\n\n        if (index == 26) {\n            color.hexNum = \"#45e9c1\";\n            color.name = \"Aphrodite Aqua\";\n        }\n\n        if (index == 27) {\n            color.hexNum = \"#424330\";\n            color.name = \"Garden Path\";\n        }\n\n        if (index == 28) {\n            color.hexNum = \"#429395\";\n            color.name = \"Catalan\";\n        }\n\n        if (index == 29) {\n            color.hexNum = \"#44dd00\";\n            color.name = \"Magic Blade\";\n        }\n\n        if (index == 30) {\n            color.hexNum = \"#432e6f\";\n            color.name = \"Her Highness\";\n        }\n\n        if (index == 31) {\n            color.hexNum = \"#4477dd\";\n            color.name = \"Andrea Blue\";\n        }\n\n        if (index == 32) {\n            color.hexNum = \"#5ad33e\";\n            color.name = \"Verdant Fields\";\n        }\n\n        if (index == 33) {\n            color.hexNum = \"#3a18b1\";\n            color.name = \"Indigo Blue\";\n        }\n\n        if (index == 34) {\n            color.hexNum = \"#556611\";\n            color.name = \"Forestial Outpost\";\n        }\n\n        if (index == 35) {\n            color.hexNum = \"#55bb88\";\n            color.name = \"Bleached Olive\";\n        }\n\n        if (index == 36) {\n            color.hexNum = \"#5500ee\";\n            color.name = \"Tezcatlipoca Blue\";\n        }\n\n        if (index == 37) {\n            color.hexNum = \"#545554\";\n            color.name = \"Carbon Copy\";\n        }\n\n        if (index == 38) {\n            color.hexNum = \"#58a0bc\";\n            color.name = \"Dupain\";\n        }\n\n        if (index == 39) {\n            color.hexNum = \"#55ff22\";\n            color.name = \"Traffic Green\";\n        }\n\n        if (index == 40) {\n            color.hexNum = \"#5b3e90\";\n            color.name = \"Daisy Bush\";\n        }\n\n        if (index == 41) {\n            color.hexNum = \"#6688ff\";\n            color.name = \"Deep Denim\";\n        }\n\n        if (index == 42) {\n            color.hexNum = \"#61e160\";\n            color.name = \"Lightish Green\";\n        }\n\n        if (index == 43) {\n            color.hexNum = \"#6a31ca\";\n            color.name = \"Sagat Purple\";\n        }\n\n        if (index == 44) {\n            color.hexNum = \"#667c3e\";\n            color.name = \"Military Green\";\n        }\n\n        if (index == 45) {\n            color.hexNum = \"#68c89d\";\n            color.name = \"Intense Jade\";\n        }\n\n        if (index == 46) {\n            color.hexNum = \"#6d1008\";\n            color.name = \"Chestnut Brown\";\n        }\n\n        if (index == 47) {\n            color.hexNum = \"#696374\";\n            color.name = \"Purple Punch\";\n        }\n\n        if (index == 48) {\n            color.hexNum = \"#6fb7e0\";\n            color.name = \"Life Force\";\n        }\n\n        if (index == 49) {\n            color.hexNum = \"#770044\";\n            color.name = \"Dawn of the Fairies\";\n        }\n\n        if (index == 50) {\n            color.hexNum = \"#7851a9\";\n            color.name = \"Royal Lavender\";\n        }\n\n        if (index == 51) {\n            color.hexNum = \"#769c18\";\n            color.name = \"Luminescent Green\";\n        }\n\n        if (index == 52) {\n            color.hexNum = \"#7be892\";\n            color.name = \"Ragweed\";\n        }\n\n        if (index == 53) {\n            color.hexNum = \"#703be7\";\n            color.name = \"Bluish Purple\";\n        }\n\n        if (index == 54) {\n            color.hexNum = \"#7b8b5d\";\n            color.name = \"Sage Leaves\";\n        }\n\n        if (index == 55) {\n            color.hexNum = \"#82d9c5\";\n            color.name = \"Tender Turquoise\";\n        }\n\n        if (index == 56) {\n            color.hexNum = \"#7e2530\";\n            color.name = \"Scarlet Shade\";\n        }\n\n        if (index == 57) {\n            color.hexNum = \"#83769c\";\n            color.name = \"Voxatron Purple\";\n        }\n\n        if (index == 58) {\n            color.hexNum = \"#88cc00\";\n            color.name = \"Fabulous Frog\";\n        }\n\n        if (index == 59) {\n            color.hexNum = \"#881166\";\n            color.name = \"Possessed Purple\";\n        }\n\n        if (index == 60) {\n            color.hexNum = \"#8756e4\";\n            color.name = \"Gloomy Purple\";\n        }\n\n        if (index == 61) {\n            color.hexNum = \"#93b13d\";\n            color.name = \"Green Tea Ice Cream\";\n        }\n\n        if (index == 62) {\n            color.hexNum = \"#90fda9\";\n            color.name = \"Foam Green\";\n        }\n\n        if (index == 63) {\n            color.hexNum = \"#914b13\";\n            color.name = \"Parasite Brown\";\n        }\n\n        if (index == 64) {\n            color.hexNum = \"#919c81\";\n            color.name = \"Whispering Willow\";\n        }\n\n        if (index == 65) {\n            color.hexNum = \"#99eeee\";\n            color.name = \"Freezy Breezy\";\n        }\n\n        if (index == 66) {\n            color.hexNum = \"#983d53\";\n            color.name = \"Algae Red\";\n        }\n\n        if (index == 67) {\n            color.hexNum = \"#9c87c1\";\n            color.name = \"Petrified Purple\";\n        }\n\n        if (index == 68) {\n            color.hexNum = \"#98da2c\";\n            color.name = \"Effervescent Lime\";\n        }\n\n        if (index == 69) {\n            color.hexNum = \"#942193\";\n            color.name = \"Acai Juice\";\n        }\n\n        if (index == 70) {\n            color.hexNum = \"#a675fe\";\n            color.name = \"Purple Illusionist\";\n        }\n\n        if (index == 71) {\n            color.hexNum = \"#a4c161\";\n            color.name = \"Jungle Juice\";\n        }\n\n        if (index == 72) {\n            color.hexNum = \"#aa00cc\";\n            color.name = \"Ferocious Fuchsia\";\n        }\n\n        if (index == 73) {\n            color.hexNum = \"#a85e39\";\n            color.name = \"Earthen Jug\";\n        }\n\n        if (index == 74) {\n            color.hexNum = \"#aaa9a4\";\n            color.name = \"Ellie Grey\";\n        }\n\n        if (index == 75) {\n            color.hexNum = \"#aaee11\";\n            color.name = \"Glorious Green Glitter\";\n        }\n\n        if (index == 76) {\n            color.hexNum = \"#ad4379\";\n            color.name = \"Mystic Maroon\";\n        }\n\n        if (index == 77) {\n            color.hexNum = \"#b195e4\";\n            color.name = \"Dreamy Candy Forest\";\n        }\n\n        if (index == 78) {\n            color.hexNum = \"#b1dd52\";\n            color.name = \"Conifer\";\n        }\n\n        if (index == 79) {\n            color.hexNum = \"#c034af\";\n            color.name = \"Pink Perennial\";\n        }\n\n        if (index == 80) {\n            color.hexNum = \"#b78727\";\n            color.name = \"University of California Gold\";\n        }\n\n        if (index == 81) {\n            color.hexNum = \"#b9d08b\";\n            color.name = \"Young Leaves\";\n        }\n\n        if (index == 82) {\n            color.hexNum = \"#bb11ee\";\n            color.name = \"Promiscuous Pink\";\n        }\n\n        if (index == 83) {\n            color.hexNum = \"#c06960\";\n            color.name = \"Tapestry Red\";\n        }\n\n        if (index == 84) {\n            color.hexNum = \"#bebbc9\";\n            color.name = \"Silverberry\";\n        }\n\n        if (index == 85) {\n            color.hexNum = \"#bf0a30\";\n            color.name = \"Old Glory Red\";\n        }\n\n        if (index == 86) {\n            color.hexNum = \"#c35b99\";\n            color.name = \"Llilacquered\";\n        }\n\n        if (index == 87) {\n            color.hexNum = \"#caa906\";\n            color.name = \"Christmas Gold\";\n        }\n\n        if (index == 88) {\n            color.hexNum = \"#c2f177\";\n            color.name = \"Cucumber Milk\";\n        }\n\n        if (index == 89) {\n            color.hexNum = \"#d648d7\";\n            color.name = \"Pinkish Purple\";\n        }\n\n        if (index == 90) {\n            color.hexNum = \"#cf9346\";\n            color.name = \"Fleshtone Shade Wash\";\n        }\n\n        if (index == 91) {\n            color.hexNum = \"#d3e0b1\";\n            color.name = \"Rockmelon Rind\";\n        }\n\n        if (index == 92) {\n            color.hexNum = \"#d22d1d\";\n            color.name = \"Pure Red\";\n        }\n\n        if (index == 93) {\n            color.hexNum = \"#d28083\";\n            color.name = \"Galah\";\n        }\n\n        if (index == 94) {\n            color.hexNum = \"#d5c7e8\";\n            color.name = \"Foggy Love\";\n        }\n\n        if (index == 95) {\n            color.hexNum = \"#db1459\";\n            color.name = \"Rubylicious\";\n        }\n\n        if (index == 96) {\n            color.hexNum = \"#dd66bb\";\n            color.name = \"Pink Charge\";\n        }\n\n        if (index == 97) {\n            color.hexNum = \"#e2b227\";\n            color.name = \"Gold Tips\";\n        }\n\n        if (index == 98) {\n            color.hexNum = \"#ee0099\";\n            color.name = \"Love Vessel\";\n        }\n\n        if (index == 99) {\n            color.hexNum = \"#dd55ff\";\n            color.name = \"Flaming Flamingo\";\n        }\n\n        if (index == 100) {\n            color.hexNum = \"#eda367\";\n            color.name = \"Adventure Orange\";\n        }\n\n        if (index == 101) {\n            color.hexNum = \"#e9f1d0\";\n            color.name = \"Yellowish White\";\n        }\n\n        if (index == 102) {\n            color.hexNum = \"#ef3939\";\n            color.name = \"Vivaldi Red\";\n        }\n\n        if (index == 103) {\n            color.hexNum = \"#e78ea5\";\n            color.name = \"Underwater Flare\";\n        }\n\n        if (index == 104) {\n            color.hexNum = \"#eedd11\";\n            color.name = \"Yellow Buzzing\";\n        }\n\n        if (index == 105) {\n            color.hexNum = \"#ee2277\";\n            color.name = \"Furious Fuchsia\";\n        }\n\n        if (index == 106) {\n            color.hexNum = \"#f075e6\";\n            color.name = \"Lian Hong Lotus Pink\";\n        }\n\n        if (index == 107) {\n            color.hexNum = \"#f7c34c\";\n            color.name = \"Creamy Sweet Corn\";\n        }\n\n        if (index == 108) {\n            color.hexNum = \"#fc0fc0\";\n            color.name = \"CGA Pink\";\n        }\n\n        if (index == 109) {\n            color.hexNum = \"#ff6622\";\n            color.name = \"Sparrows Fire\";\n        }\n\n        if (index == 110) {\n            color.hexNum = \"#fbaf8d\";\n            color.name = \"Orange Grove\";\n        }\n\n        // AUTOGEN:END\n    }\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard\n */\ninterface IERC2981Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Called with the sale price to determine how much royalty is owed and to whom.\n     * @param tokenId - the NFT asset queried for royalty information\n     * @param salePrice - the sale price of the NFT asset specified by `tokenId`\n     * @return receiver - address of who should be sent the royalty payment\n     * @return royaltyAmount - the royalty payment amount for `salePrice`\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "gwei-slim-nft-contracts/contracts/base/IBaseERC721Interface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\n/// Additional features and functions assigned to the\n/// Base721 contract for hooks and overrides\ninterface IBaseERC721Interface {\n    /*\n     Exposing common NFT internal functionality for base contract overrides\n     To save gas and make API cleaner this is only for new functionality not exposed in\n     the core ERC721 contract\n    */\n\n    /// Mint an NFT. Allowed to mint by owner, approval or by the parent contract\n    /// @param tokenId id to burn\n    function __burn(uint256 tokenId) external;\n\n    /// Mint an NFT. Allowed only by the parent contract\n    /// @param to address to mint to\n    /// @param tokenId token id to mint\n    function __mint(address to, uint256 tokenId) external;\n\n    /// Set the base URI of the contract. Allowed only by parent contract\n    /// @param base base uri\n    /// @param extension extension\n    function __setBaseURI(string memory base, string memory extension) external;\n\n    /* Exposes common internal read features for public use */\n\n    /// Token exists\n    /// @param tokenId token id to see if it exists\n    function __exists(uint256 tokenId) external view returns (bool);\n\n    /// Simple approval for operation check on token for address\n    /// @param spender address spending/changing token\n    /// @param tokenId tokenID to change / operate on\n    function __isApprovedOrOwner(address spender, uint256 tokenId)\n        external\n        view\n        returns (bool);\n\n    function __isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    function __tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function __owner() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/InflateLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.9.0;\n\n//\n// inflate content script:\n// var pako = require('pako')\n// var deflate = (str) => [str.length,Buffer.from(pako.deflateRaw(Buffer.from(str, 'utf-8'), {level: 9})).toString('hex')]\n//\n\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\nlibrary InflateLib {\n    // Maximum bits in a code\n    uint256 constant MAXBITS = 15;\n    // Maximum number of literal/length codes\n    uint256 constant MAXLCODES = 286;\n    // Maximum number of distance codes\n    uint256 constant MAXDCODES = 30;\n    // Maximum codes lengths to read\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\n    // Number of fixed literal/length codes\n    uint256 constant FIXLCODES = 288;\n\n    // Error codes\n    enum ErrorCode {\n        ERR_NONE, // 0 successful inflate\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\n        ERR_CONSTRUCT // 14 internal: error in construct()\n    }\n\n    // Input and output state\n    struct State {\n        //////////////////\n        // Output state //\n        //////////////////\n        // Output buffer\n        bytes output;\n        // Bytes written to out so far\n        uint256 outcnt;\n        /////////////////\n        // Input state //\n        /////////////////\n        // Input buffer\n        bytes input;\n        // Bytes read so far\n        uint256 incnt;\n        ////////////////\n        // Temp state //\n        ////////////////\n        // Bit buffer\n        uint256 bitbuf;\n        // Number of bits in bit buffer\n        uint256 bitcnt;\n        //////////////////////////\n        // Static Huffman codes //\n        //////////////////////////\n        Huffman lencode;\n        Huffman distcode;\n    }\n\n    // Huffman code decoding tables\n    struct Huffman {\n        uint256[] counts;\n        uint256[] symbols;\n    }\n\n    function bits(State memory s, uint256 need)\n        private\n        pure\n        returns (ErrorCode, uint256)\n    {\n        // Bit accumulator (can use up to 20 bits)\n        uint256 val;\n\n        // Load at least need bits into val\n        val = s.bitbuf;\n        while (s.bitcnt < need) {\n            if (s.incnt == s.input.length) {\n                // Out of input\n                return (ErrorCode.ERR_NOT_TERMINATED, 0);\n            }\n\n            // Load eight bits\n            val |= uint256(uint8(s.input[s.incnt++])) << s.bitcnt;\n            s.bitcnt += 8;\n        }\n\n        // Drop need bits and update buffer, always zero to seven bits left\n        s.bitbuf = val >> need;\n        s.bitcnt -= need;\n\n        // Return need bits, zeroing the bits above that\n        uint256 ret = (val & ((1 << need) - 1));\n        return (ErrorCode.ERR_NONE, ret);\n    }\n\n    function _stored(State memory s) private pure returns (ErrorCode) {\n        // Length of stored block\n        uint256 len;\n\n        // Discard leftover bits from current byte (assumes s.bitcnt < 8)\n        s.bitbuf = 0;\n        s.bitcnt = 0;\n\n        // Get length and check against its one's complement\n        if (s.incnt + 4 > s.input.length) {\n            // Not enough input\n            return ErrorCode.ERR_NOT_TERMINATED;\n        }\n        len = uint256(uint8(s.input[s.incnt++]));\n        len |= uint256(uint8(s.input[s.incnt++])) << 8;\n\n        if (\n            uint8(s.input[s.incnt++]) != (~len & 0xFF) ||\n            uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)\n        ) {\n            // Didn't match complement!\n            return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\n        }\n\n        // Copy len bytes from in to out\n        if (s.incnt + len > s.input.length) {\n            // Not enough input\n            return ErrorCode.ERR_NOT_TERMINATED;\n        }\n        if (s.outcnt + len > s.output.length) {\n            // Not enough output space\n            return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n        }\n        while (len != 0) {\n            // Note: Solidity reverts on underflow, so we decrement here\n            len -= 1;\n            s.output[s.outcnt++] = s.input[s.incnt++];\n        }\n\n        // Done with a valid stored block\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _decode(State memory s, Huffman memory h)\n        private\n        pure\n        returns (ErrorCode, uint256)\n    {\n        // Current number of bits in code\n        uint256 len;\n        // Len bits being decoded\n        uint256 code = 0;\n        // First code of length len\n        uint256 first = 0;\n        // Number of codes of length len\n        uint256 count;\n        // Index of first code of length len in symbol table\n        uint256 index = 0;\n        // Error code\n        ErrorCode err;\n\n        for (len = 1; len <= MAXBITS; len++) {\n            // Get next bit\n            uint256 tempCode;\n            (err, tempCode) = bits(s, 1);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, 0);\n            }\n            code |= tempCode;\n            count = h.counts[len];\n\n            // If length len, return symbol\n            if (code < first + count) {\n                return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\n            }\n            // Else update for next length\n            index += count;\n            first += count;\n            first <<= 1;\n            code <<= 1;\n        }\n\n        // Ran out of codes\n        return (ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE, 0);\n    }\n\n    function _construct(\n        Huffman memory h,\n        uint256[] memory lengths,\n        uint256 n,\n        uint256 start\n    ) private pure returns (ErrorCode) {\n        // Current symbol when stepping through lengths[]\n        uint256 symbol;\n        // Current length when stepping through h.counts[]\n        uint256 len;\n        // Number of possible codes left of current length\n        uint256 left;\n        // Offsets in symbol table for each length\n        uint256[MAXBITS + 1] memory offs;\n\n        // Count number of codes of each length\n        for (len = 0; len <= MAXBITS; len++) {\n            h.counts[len] = 0;\n        }\n        for (symbol = 0; symbol < n; symbol++) {\n            // Assumes lengths are within bounds\n            h.counts[lengths[start + symbol]]++;\n        }\n        // No codes!\n        if (h.counts[0] == n) {\n            // Complete, but decode() will fail\n            return (ErrorCode.ERR_NONE);\n        }\n\n        // Check for an over-subscribed or incomplete set of lengths\n\n        // One possible code of zero length\n        left = 1;\n\n        for (len = 1; len <= MAXBITS; len++) {\n            // One more bit, double codes left\n            left <<= 1;\n            if (left < h.counts[len]) {\n                // Over-subscribed--return error\n                return ErrorCode.ERR_CONSTRUCT;\n            }\n            // Deduct count from possible codes\n\n            left -= h.counts[len];\n        }\n\n        // Generate offsets into symbol table for each length for sorting\n        offs[1] = 0;\n        for (len = 1; len < MAXBITS; len++) {\n            offs[len + 1] = offs[len] + h.counts[len];\n        }\n\n        // Put symbols in table sorted by length, by symbol order within each length\n        for (symbol = 0; symbol < n; symbol++) {\n            if (lengths[start + symbol] != 0) {\n                h.symbols[offs[lengths[start + symbol]]++] = symbol;\n            }\n        }\n\n        // Left > 0 means incomplete\n        return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\n    }\n\n    function _codes(\n        State memory s,\n        Huffman memory lencode,\n        Huffman memory distcode\n    ) private pure returns (ErrorCode) {\n        // Decoded symbol\n        uint256 symbol;\n        // Length for copy\n        uint256 len;\n        // Distance for copy\n        uint256 dist;\n        // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\n        // Size base for length codes 257..285\n        uint16[29] memory lens =\n            [\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                13,\n                15,\n                17,\n                19,\n                23,\n                27,\n                31,\n                35,\n                43,\n                51,\n                59,\n                67,\n                83,\n                99,\n                115,\n                131,\n                163,\n                195,\n                227,\n                258\n            ];\n        // Extra bits for length codes 257..285\n        uint8[29] memory lext =\n            [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                1,\n                1,\n                2,\n                2,\n                2,\n                2,\n                3,\n                3,\n                3,\n                3,\n                4,\n                4,\n                4,\n                4,\n                5,\n                5,\n                5,\n                5,\n                0\n            ];\n        // Offset base for distance codes 0..29\n        uint16[30] memory dists =\n            [\n                1,\n                2,\n                3,\n                4,\n                5,\n                7,\n                9,\n                13,\n                17,\n                25,\n                33,\n                49,\n                65,\n                97,\n                129,\n                193,\n                257,\n                385,\n                513,\n                769,\n                1025,\n                1537,\n                2049,\n                3073,\n                4097,\n                6145,\n                8193,\n                12289,\n                16385,\n                24577\n            ];\n        // Extra bits for distance codes 0..29\n        uint8[30] memory dext =\n            [\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                2,\n                2,\n                3,\n                3,\n                4,\n                4,\n                5,\n                5,\n                6,\n                6,\n                7,\n                7,\n                8,\n                8,\n                9,\n                9,\n                10,\n                10,\n                11,\n                11,\n                12,\n                12,\n                13,\n                13\n            ];\n        // Error code\n        ErrorCode err;\n\n        // Decode literals and length/distance pairs\n        while (symbol != 256) {\n            (err, symbol) = _decode(s, lencode);\n            if (err != ErrorCode.ERR_NONE) {\n                // Invalid symbol\n                return err;\n            }\n\n            if (symbol < 256) {\n                // Literal: symbol is the byte\n                // Write out the literal\n                if (s.outcnt == s.output.length) {\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n                }\n                s.output[s.outcnt] = bytes1(uint8(symbol));\n                s.outcnt++;\n            } else if (symbol > 256) {\n                uint256 tempBits;\n                // Length\n                // Get and compute length\n                symbol -= 257;\n                if (symbol >= 29) {\n                    // Invalid fixed code\n                    return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\n                }\n\n                (err, tempBits) = bits(s, lext[symbol]);\n                if (err != ErrorCode.ERR_NONE) {\n                    return err;\n                }\n                len = lens[symbol] + tempBits;\n\n                // Get and check distance\n                (err, symbol) = _decode(s, distcode);\n                if (err != ErrorCode.ERR_NONE) {\n                    // Invalid symbol\n                    return err;\n                }\n                (err, tempBits) = bits(s, dext[symbol]);\n                if (err != ErrorCode.ERR_NONE) {\n                    return err;\n                }\n                dist = dists[symbol] + tempBits;\n                if (dist > s.outcnt) {\n                    // Distance too far back\n                    return ErrorCode.ERR_DISTANCE_TOO_FAR;\n                }\n\n                // Copy length bytes from distance bytes back\n                if (s.outcnt + len > s.output.length) {\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n                }\n                while (len != 0) {\n                    // Note: Solidity reverts on underflow, so we decrement here\n                    len -= 1;\n                    s.output[s.outcnt] = s.output[s.outcnt - dist];\n                    s.outcnt++;\n                }\n            } else {\n                s.outcnt += len;\n            }\n        }\n\n        // Done with a valid fixed or dynamic block\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\n        // Build fixed Huffman tables\n        // TODO this is all a compile-time constant\n        uint256 symbol;\n        uint256[] memory lengths = new uint256[](FIXLCODES);\n\n        // Literal/length table\n        for (symbol = 0; symbol < 144; symbol++) {\n            lengths[symbol] = 8;\n        }\n        for (; symbol < 256; symbol++) {\n            lengths[symbol] = 9;\n        }\n        for (; symbol < 280; symbol++) {\n            lengths[symbol] = 7;\n        }\n        for (; symbol < FIXLCODES; symbol++) {\n            lengths[symbol] = 8;\n        }\n\n        _construct(s.lencode, lengths, FIXLCODES, 0);\n\n        // Distance table\n        for (symbol = 0; symbol < MAXDCODES; symbol++) {\n            lengths[symbol] = 5;\n        }\n\n        _construct(s.distcode, lengths, MAXDCODES, 0);\n\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _fixed(State memory s) private pure returns (ErrorCode) {\n        // Decode data until end-of-block code\n        return _codes(s, s.lencode, s.distcode);\n    }\n\n    function _build_dynamic_lengths(State memory s)\n        private\n        pure\n        returns (ErrorCode, uint256[] memory)\n    {\n        uint256 ncode;\n        // Index of lengths[]\n        uint256 index;\n        // Descriptor code lengths\n        uint256[] memory lengths = new uint256[](MAXCODES);\n        // Error code\n        ErrorCode err;\n        // Permutation of code length codes\n        uint8[19] memory order =\n            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n        (err, ncode) = bits(s, 4);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lengths);\n        }\n        ncode += 4;\n\n        // Read code length code lengths (really), missing lengths are zero\n        for (index = 0; index < ncode; index++) {\n            (err, lengths[order[index]]) = bits(s, 3);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, lengths);\n            }\n        }\n        for (; index < 19; index++) {\n            lengths[order[index]] = 0;\n        }\n\n        return (ErrorCode.ERR_NONE, lengths);\n    }\n\n    function _build_dynamic(State memory s)\n        private\n        pure\n        returns (\n            ErrorCode,\n            Huffman memory,\n            Huffman memory\n        )\n    {\n        // Number of lengths in descriptor\n        uint256 nlen;\n        uint256 ndist;\n        // Index of lengths[]\n        uint256 index;\n        // Error code\n        ErrorCode err;\n        // Descriptor code lengths\n        uint256[] memory lengths = new uint256[](MAXCODES);\n        // Length and distance codes\n        Huffman memory lencode =\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\n        Huffman memory distcode =\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\n        uint256 tempBits;\n\n        // Get number of lengths in each table, check lengths\n        (err, nlen) = bits(s, 5);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n        nlen += 257;\n        (err, ndist) = bits(s, 5);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n        ndist += 1;\n\n        if (nlen > MAXLCODES || ndist > MAXDCODES) {\n            // Bad counts\n            return (\n                ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES,\n                lencode,\n                distcode\n            );\n        }\n\n        (err, lengths) = _build_dynamic_lengths(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n\n        // Build huffman table for code lengths codes (use lencode temporarily)\n        err = _construct(lencode, lengths, 19, 0);\n        if (err != ErrorCode.ERR_NONE) {\n            // Require complete code set here\n            return (\n                ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE,\n                lencode,\n                distcode\n            );\n        }\n\n        // Read length/literal and distance code length tables\n        index = 0;\n        while (index < nlen + ndist) {\n            // Decoded value\n            uint256 symbol;\n            // Last length to repeat\n            uint256 len;\n\n            (err, symbol) = _decode(s, lencode);\n            if (err != ErrorCode.ERR_NONE) {\n                // Invalid symbol\n                return (err, lencode, distcode);\n            }\n\n            if (symbol < 16) {\n                // Length in 0..15\n                lengths[index++] = symbol;\n            } else {\n                // Repeat instruction\n                // Assume repeating zeros\n                len = 0;\n                if (symbol == 16) {\n                    // Repeat last length 3..6 times\n                    if (index == 0) {\n                        // No last length!\n                        return (\n                            ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH,\n                            lencode,\n                            distcode\n                        );\n                    }\n                    // Last length\n                    len = lengths[index - 1];\n                    (err, tempBits) = bits(s, 2);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 3 + tempBits;\n                } else if (symbol == 17) {\n                    // Repeat zero 3..10 times\n                    (err, tempBits) = bits(s, 3);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 3 + tempBits;\n                } else {\n                    // == 18, repeat zero 11..138 times\n                    (err, tempBits) = bits(s, 7);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 11 + tempBits;\n                }\n\n                if (index + symbol > nlen + ndist) {\n                    // Too many lengths!\n                    return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\n                }\n                while (symbol != 0) {\n                    // Note: Solidity reverts on underflow, so we decrement here\n                    symbol -= 1;\n\n                    // Repeat last or zero symbol times\n                    lengths[index++] = len;\n                }\n            }\n        }\n\n        // Check for end-of-block code -- there better be one!\n        if (lengths[256] == 0) {\n            return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\n        }\n\n        // Build huffman table for literal/length codes\n        err = _construct(lencode, lengths, nlen, 0);\n        if (\n            err != ErrorCode.ERR_NONE &&\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\n                nlen != lencode.counts[0] + lencode.counts[1])\n        ) {\n            // Incomplete code ok only for single length 1 code\n            return (\n                ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS,\n                lencode,\n                distcode\n            );\n        }\n\n        // Build huffman table for distance codes\n        err = _construct(distcode, lengths, ndist, nlen);\n        if (\n            err != ErrorCode.ERR_NONE &&\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\n                ndist != distcode.counts[0] + distcode.counts[1])\n        ) {\n            // Incomplete code ok only for single length 1 code\n            return (\n                ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS,\n                lencode,\n                distcode\n            );\n        }\n\n        return (ErrorCode.ERR_NONE, lencode, distcode);\n    }\n\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\n        // Length and distance codes\n        Huffman memory lencode;\n        Huffman memory distcode;\n        // Error code\n        ErrorCode err;\n\n        (err, lencode, distcode) = _build_dynamic(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return err;\n        }\n\n        // Decode data until end-of-block code\n        return _codes(s, lencode, distcode);\n    }\n\n    function puff(bytes memory source, uint256 destlen)\n        internal\n        pure\n        returns (ErrorCode, bytes memory)\n    {\n        // Input/output state\n        State memory s =\n            State(\n                new bytes(destlen),\n                0,\n                source,\n                0,\n                0,\n                0,\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\n            );\n        // Temp: last bit\n        uint256 last;\n        // Temp: block type bit\n        uint256 t;\n        // Error code\n        ErrorCode err;\n\n        // Build fixed Huffman tables\n        err = _build_fixed(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, s.output);\n        }\n\n        // Process blocks until last block or error\n        while (last == 0) {\n            // One if last block\n            (err, last) = bits(s, 1);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, s.output);\n            }\n\n            // Block type 0..3\n            (err, t) = bits(s, 2);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, s.output);\n            }\n\n            err = (\n                t == 0\n                    ? _stored(s)\n                    : (\n                        t == 1\n                            ? _fixed(s)\n                            : (\n                                t == 2\n                                    ? _dynamic(s)\n                                    : ErrorCode.ERR_INVALID_BLOCK_TYPE\n                            )\n                    )\n            );\n            // type == 3, invalid\n\n            if (err != ErrorCode.ERR_NONE) {\n                // Return with error\n                break;\n            }\n        }\n\n        return (err, s.output);\n    }\n}\n"
    },
    "contracts/GmDataInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface GmDataInterface {\n    struct GmDataSet {\n        bytes imageName;\n        bytes compressedImage;\n        uint256 compressedSize;\n    }\n\n    function getSvg(uint256 index) external pure returns (GmDataSet memory);\n}\n"
    },
    "contracts/TestBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport {ERC721Base} from \"gwei-slim-nft-contracts/contracts/base/ERC721Base.sol\";\n\ncontract TestBase is ERC721Base {\n\n}"
    },
    "contracts/GmData2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {GmDataInterface} from \"./GmDataInterface.sol\";\n\ncontract GmData2 is GmDataInterface {\n    function getSvg(uint256 index)\n        external\n        pure\n        returns (\n           GmDataSet memory data \n        )\n    {\n        // AUTOGEN:START\n\n    if (index == 50) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373236525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b1505748a954b055373453b75353ae3030303076b11e6c0c1b7db08b471d3eea705a39dcd10027038f85781413234581c3c9b39918ef92c4a04d8893e470b2a5a897c607b7c3a99e54e81ee203923969935406aa38d407350aec00\";\n      data.compressedSize = 2075;\n      data.imageName = \"Reverse\";\n    }\n  \n    if (index == 51) {\n      data.compressedImage = hex\"ad965d0b82301486ffca206878d55c91851f10a1bf4258f6711715e885c1f9f1a9d5666bcea378e5cbd839ee39efeb47505cca82942165943c43ca571b4a4ed72ccf437accf20b8d82227f64b77a87bb5d52727e924aad69349f958cb11df335c1e35a70ee725f7c563cdf289a3ded22633fd578df2ed2afc826e3ba058b6608d85954785ff48d6ae208cba1d2ff25c0c0a49d7c096a1880660449a438ee5209a7f3b8d2751bd3db0e339c05c55806037dfbcf8d82ac6e201c790c2104d8582015fdc14b8c95437d4025a5f52c22aeef0243334b98dbdec00456788332aebf466c638f551174daad657a4a3433c8419bbfd7acf43faddd969ba2db131618fba2b399334ea0f334484cccfce39ef573a6895fa771b1c6d5a0668be92ba7b1a87f0ca217\";\n      data.compressedSize = 2079;\n      data.imageName = \"Flower Power\";\n    }\n  \n    if (index == 52) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373235535748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303435565748a95400b2ccd4edd4942b0c0c0c1c0dacc963c45351884eca311936fae0c0a14e1841ad36b2b08ed7249209d78e2e1d4f942e1afb89682bc9329238d3a9a36a344c681e26e465fe21ef7762a393f8a26028fa99ecc29f06d989168c014d2f8339608809337d500bc50e00\";\n      data.compressedSize = 2216;\n      data.imageName = \"Dot Matrix\";\n    }\n  \n    if (index == 53) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b4553732b1505748ce492c2eb6554f4a2c4e55b7b329292e48cc03a930b400caa5542a005966ea766aca150606068e06d6988cfcf878383b3e3e1fc23672c3a232064d29368dc8ea6df4c1ae21d95140cbcbf03818935143354594a9367625dbf3f0004736837806727cc550a488aaaa890e841832fc0c4e9178932b1e492aa8223d79e793e7cbc192bca991b78d9dad6390ca0d4c59741157eb21989ca9c5a8a1ba89b463101d38f9b8e31f7b05351c03016b6e803129ac0c06dcf3faa0668a1d00\";\n      data.compressedSize = 2221;\n      data.imageName = \"Acrobatic\";\n    }\n  \n    if (index == 54) {\n      data.compressedImage = hex\"cd56cb0a833010fc9540a14b4fc608b5a0117aa85f2144fbb895528807857c7cb550b559b509b6252787ec66ddd9194de2f25295a4e24081d41c58c0809cae85941c8e85bc401297f25edcda0c460320e79a70f0b790ac5715a5744fa3af0321ccd60641615237f69e54ac19b1430b18f3d9f0d9055a90469b6e93c27554978663b95e2b9ce3a0672fe0d775835fdd802c9ba43133e5f7514d356a9fdb6f0acdf92a034926d08f978c95ca726d44c81ca39e728f886eb9dd0b0c98e533ea3b28cda833f5bfc484bd5d156844a9102985ccd830cb9410638d7c5e35ee5029ab53c432fd0fc0d65ac3f9a283b017288d5c23bac07db9e9c714bacb1ad3f7da4b56f200\";\n      data.compressedSize = 2411;\n      data.imageName = \"Crazy\";\n    }\n  \n    if (index == 55) {\n      data.compressedImage = hex\"b596cd0ac2300cc75fa52098e3ea0682b80d76f1290a65ea6e2242779830faec768afbd01a9bad851e42bb26ff5f93b44bebaaa95993010776cf204e6260a74ba95406c7525590a7b5ba95d7ee8bcd2e0176be33636d215faf1ace79c1f724434a396f63d02869f484f4c91a1fb0251188ddb87ea3bb46f1c78e23bf8ca418295d88dcfe9ceaa318438464a7227bab0494bdc5e0e732cfcceef7da9f9c48d99a31b008cb2e22c3b42b2c52a5f8cc874524eac56a0c491a7975d66e3924549cd62e85877bd55a8c0f835e2b24d1a45e591e25d83de822878a1814dac79d8fca59881a02deeb1b3fe912ef6f39d97bcf16757f73f903\";\n      data.compressedSize = 2516;\n      data.imageName = \"Isometric3\";\n    }\n  \n    if (index == 56) {\n      data.compressedImage = hex\"d596c10ac32010447f4528748f31467aa906fc94b4cdad94823998bf6f938217d3edba9a434f19c8ec8c4f85c44c639844b02041cc16947e3faff7c17b0b97c18fd09bc93f87c7e2506d07e2360b0bed09fae32148299d3c7f84ae245c22f46ec26d09d3acc03fb8f53f736b3eb76af3769321d2e4585add53c0bd1956222815b53c55b935a19972cfa31961420289a599dcbc452153b9e7f46d6a9ff3ee5c0601b21331a7d05c5ecae5a62c2a352353bc0a760e8d3b4d4550100f859b62a670e3e3c5dc59afb216cefb2e10c72377b3fcd1f52f\";\n      data.compressedSize = 2520;\n      data.imageName = \"Poison\";\n    }\n  \n    if (index == 57) {\n      data.compressedImage = hex\"ed96410b832014c7bf8a3098c72c581b588187dd07efe4a9d5ea36c6c00e75e9b3cfc6322833a943b14d10fee97bfff753500b8abc2c501962825115628f9c30badd1321429c2622c751508867f268223c57ce65150ab1ebe368bf2b09218c502504c82686e33de19d29c4206457df869cc079d79fc6c83e6e076a1070315141dd22312ab5896f0aaba3695d8e747267b402fa4e72ecca87a6ba386b5c63f262dcc579b6f8fe1f7f9e9331ef07f185f6225b158fd1b43bff3076c7e9cab299b86c192e581d978d60772e1037efd8d6b094e03507e09a32b02ad6d6c4f843ff15cbe336416a994ef38f17bd00\";\n      data.compressedSize = 2538;\n      data.imageName = \"AMC AAA01\";\n    }\n  \n    if (index == 58) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373236525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93034b7505748a95400b2ccd4edd4942b0c0c0c1c0dac71318c9cadd381008943a416389b544164036df4c1ee26c1f9290150e38c70bbcfc83ad2c2138feb2d70190114b108205b12d39f447b2f13a6d9dc9a60f0a3f8048b373d2df0e8c41d2e244812e72da0f3522cf0c43da66f52301c00120ca089772293e03610f24e0052b202020417998737e2c8776642a405e979840c0672e8939408079c4183e0414a75c0b0c01b3f232058f015988492efb00e1ef20bda611d2c09380b7d1c15d6082b6380453ae136ccd00a167d50f3d40e00\";\n      data.compressedSize = 2725;\n      data.imageName = \"NV Script\";\n    }\n  \n    if (index == 59) {\n      data.compressedImage = hex\"ed56c18ac23010fd9580608ea6a9b681b48582f120e2753d49aaedc2c2b208ad502ffd761309b5d46c4cd4835df6364d66debc7993491a55455d813a860882530cb11740b0ffceca3286bbac2c601255e521fb911e5ee843909f80b002988c4735422845f41d0cccfa865394532e3fb5728e2617e15ea3df71f5a43a84905bf675bbda8db9ae6af571ac4b601c0b81b8de1b3ad570e1411ab5114ab61baef82ee4d727b7ce9f13c29437c632967183401bad04327fbf8eb0a3e123ba4826da4ccca691ff3c07cc532105fab9bccf579c6365a4b4459bdd6ceabc3035d4833dca1de7fa82ad013754693678e3708f613bc8d69bbfe27ee6f6c9d585f3564fa3ab61790e18cd3fbe4c4df8eb3a4caf2f56376cd99fcf8196ef3e27dbde9cf8f35f0d9c52ab191db45e13f9679d9c01\";\n      data.compressedSize = 2912;\n      data.imageName = \"Fraktur\";\n    }\n  \n    if (index == 60) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b4553732b0505748ce492c2eb6554f4a2c4e55b7b329292e48cc03a930b400caa5542a005966ea766aca150606068e06d60419466ed6cacacac4a8c75486552ff106dae8835d4fbe27805611e34cacea61aa50c59471190cf61531e692eb29ac7ec1e33bfceab1b95599442f93e219e2229c44e57855912f39eaa9514f8d7a6a803c855cf0800179350f498214d7336806d3d4d5d4702c89e94699ea66528b41416010485b83d0d7247a16d2cec2dfda19ea314b64a388d4d6d1a00d0c7d507bdf0e00\";\n      data.compressedSize = 3062;\n      data.imageName = \"Caligraphy2\";\n    }\n  \n    if (index == 61) {\n      data.compressedImage = hex\"c557cb6ac33010fc15c140758cea945efc80500b1f94bbcf6e1b43442905ebe0fc7d5629b46eddb8b22d29b7315ed69ad9dd59393387deb03ee782b353ce93e481b397b7a6eb72fedc74075e64a6fb68de6dc4fde396b3d713b3881777e885103b910602894c2b13fa234141b6b948174f418dfa136f77f188529d7e819509e9f081954b15daf81d913ca5f5175a26b4340194b18386d26f0d1d81011628628584172534d46dac610f37e69ae21633a5d42e8d4e6155b9d60224f424a30aad5c5533f2b6e3c46b4a3ecf02eafafb617472b22085e330b9bfb91b8edbd0a71d1968c88951055a4c998c5726d73a4e5d6742872eb17749488daf5c96596046a3611c2f2b35b3f530d36c2332fcab55cdbffb7ef1d240e5fde27123a57e584bc0dc3ac26d7563ff088a33\";\n      data.compressedSize = 3096;\n      data.imageName = \"Def Leppard\";\n    }\n  \n    if (index == 62) {\n      data.compressedImage = hex\"cd97cd0ac2300cc75fa52098e3ea865ef6015e7c8a4298ba9b88d01db6b7b7ed41a71db55dda610f23b4a3f9e79734a555df0d3d1b6ae0c0c61af2220776b9b552d6706e65074dd5cb477bd77fecf605b0ebc894758066bb1938e7475ec63230fa8ed1dc53a5559981b812cbfc548ad794588da1768bc2b67ff05b858dd2632fa58764bb25ce7c714dc96e56c504198a64c53a75ed5cf49949c0c853c25b303aaa905ac4a886faf82b8bca24341b6806a9f8344f9ceee3c64a8e75f19135a9b18e09b97896e989ca66b184cf143aba5cac08136d18cece5382b3acdd17c3ff230b6417820cbd6e075a474e8ac49b8ddd053d1b21d1887d9bcdc69ce9d748f304\";\n      data.compressedSize = 3220;\n      data.imageName = \"Impossible\";\n    }\n  \n    if (index == 63) {\n      data.compressedImage = hex\"dd57cd6e83300c7e9548959663d3541aad0a485d459f0289d0adb7699a04072af9e117c66085901f87761ae582e598c49ffdd9316179ae4a52459451728928671b4a5edff3a288e8292fce340ecbe233ffa82d56db35256f1722a5671a3f2d2ac6d89eede62864f2312c87cb6fd08f839d1f5a21b0db488df85125738f49038af3156f152f4345179a642446bf2c81c991e8fba27b379e643ae7bc205e7d8ce04a0dda1b353f3a9ca4b75179aa1a8fc7739049b0f2be975b1fe46005badee3b80b80735657e4bd546a77bab69a8275b826d3906a7d4d76a8ad8e4623d0f020f0eeed867a1b29227910368b2a31c0210c071c8f1cb1060ea59ae06c6e86dda58f4cbbc385ae190b854d80ad50100e8cbc0f2cb515b6238f0c699a8de400ec8cf7cec67d30deb8f376c64d9a4c3774f0a7b30c7ee2480dbba51ef7f1ff1126cca1c25ee1339aecbb402ceb5fb8f80b\";\n      data.compressedSize = 3529;\n      data.imageName = \"3D Diagonal\";\n    }\n  \n    if (index == 64) {\n      data.compressedImage = hex\"e5d74b0e82301000d0ab343171965448b4864f620c7b4f608acace884959c0eda568140d9f960e12945517d329f3ca50f0d2384b49e6030592fb603b3690e33912c28743246208bc545ca38b8c583b404e39f161b184603ecb28a51beafec9c00ea797b93af0ac721f11b7d3deba092bafe46b85146b32dcc5f0330ec52fa5b5d6e46c002bb39ce61930995f7bdf87b70edcc826943ba6a3a33f039991a1f2e1f773ab8e7ae4eff3552c560d2a45c41ed76b324c6f3a75dd5ed5e88e08c766ba9fda4ca9cad6b71c673d66683aa896cf07784a8a5bfc2c5055a95dc13c83aae3181f1e95b31e4daf59c3bccb355c313fa3f9a30f774d22985a35cbe367ec747cf259f2b733b801\";\n      data.compressedSize = 3709;\n      data.imageName = \"Broadway\";\n    }\n  \n    if (index == 65) {\n      data.compressedImage = hex\"d557cd0ac2300c7e9582608ed60982b80dbcf8148131753711a13b4cc8c3eba66ef36fb669bbe94e656dd2f4fb922f6d9867452e8a0824885304c12c00b1dda74a45b04955067198ab637a28572c6620762711c1740ef1785448295772693948cacf953317b1247e220a27158e0c38ab7850670f1c00c860ddc75e38300dbc535eacc8c88c7e84ad8439e78c2f339ad8ecbcfe696adf983c4f35532feeb642f4c8cb173ab8494e95b4912721f181723fb87b859bd9ddcc71491e6a89e9c5055c66e023617f5dcb3ee9b17d4ff0e8dd224baf99805a694bd8a1bf377dd6d668c2fb72b4089f78d5f221cad6889cf517bd60c9fd3d838c3b363e88beee3617aba64dd43ac6ec1cf8ecc0ea7a6e7690379a38f8b3e78f06354d93f2d91a9f01\";\n      data.compressedSize = 3773;\n      data.imageName = \"Patorjk-HeX\";\n    }\n  \n    if (index == 66) {\n      data.compressedImage = hex\"d597dd0a823014805f651034ba725958900a11f41483613f7711815e189c87cf458aa6e9b6e389ea6ac4767ebef36b989df38ce511179cdd23eecf03ce8e97244d237e48d2338fc32cbd25577d63be5c7076bab3e214f0783ac985105bb1b13a28fd737b3a24557dfabf4f5fe83dddb3f0b29007d2c42889740adc9ebdd4fa7b2c5489a665654371990c2b1ec668e677f83144151cb30574ee03111c237fdba2ad3101159dee6e410849aa1e28c8caa1a7642600b01d4e4299b178285fcc212863bb23a132fe7b70a934592f1559554b4f5c746a82bea9d0d3b0b799157acc636cd4123b9a4123a500cd9b2c96753b8d27b604a36131a0ae294e013ed69dd2edb7b6d67ab4b65067b376ad09378d999b8d085aefa15e1198e7325757bfab623cda3f42e22f0e15754f7fcfc60f\";\n      data.compressedSize = 3798;\n      data.imageName = \"Patorjk's Cheese\";\n    }\n  \n    if (index == 67) {\n      data.compressedImage = hex\"ed99c90a833010865f2550e81c8d08a5e0023e4ada4a2e4d29c483be7db11b426dc66cad4b721af0cfe87c936512b3ba6a6ad2e44081b439c4bb3d90e3994999c381c90a8aac965776e914719c0039b5a45341b1dd3494d292a69f067f354ca3782e1e4da1d09066d13d088d589e9f9694a92be31d2e22eb8565f9c60122d62e853e53f7289da544f8f32d7cfac6d873e321ca8dbb8ac9a6f99f6cf99805cc70aa70c3692d4cc7a66ec7e5b2546d363f7210d8ce85ad1ee4c0d6bacee26b6738ddda6bc1ac7b479bc0d837e3ef874e6b66d86172a4c0454cae0c9fb5c01c0d740fc26e27026b77ac357777e51210d89bdd7b71af775a210773a81f969f0a8b9c0cd61b9693660da4fdb047cbc035031ec33eeafefa1437\";\n      data.compressedSize = 6652;\n      data.imageName = \"Doh\";\n    }\n  \n    if (index == 68) {\n      data.compressedImage = hex\"ed9ac16ac3300c865fc530988ff55a36064d02bdec290425db7a1b63901c52307df6c51d2cd0a5992c5b7654e2930e8ef1af4fb22d3b457be85ad595da68752cf5c3e35aabb78fba694afd5a37075d156df3557fba1ecf1badde8faaeff4a4abfbbbce18b333dbe8c6de35bee1c54ebc589d492406b27ed902a6374801954f505280bdcc1f63b31b0cc924c705b994034980466548268514642706b202002265ca21e92b4828408ccc614b9831417200ca0287e47515c06c08228558a1c0c89ce646ce578830601139fded9c921c59c818b0fed468f757ea353f47b3fa979a2b5387e2f0095bda3e141c222830487903fa51ad8303bdb7d44b37450c90688ebfa89ffe716cf42c9f2ac1a7dd754e5a0bd113ede41a5f42639794604fa36a7fe05ba7009b6009d67dccc4bd37552a21dc770ceecb5287840712fd78ca4228ea3593441e310b3d12a1c4326f9e23cb950b82ecc2915b20cb2528841c34179e5104f23e4fc0c23397c0440f8340af87f31a30b740ccf3147fc346aac2e717dccafdf6527d03\";\n      data.compressedSize = 8957;\n      data.imageName = \"Alpha\";\n    }\n  \n// AUTOGEN:END\n        return data;\n    }\n}\n"
    },
    "contracts/GmData1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {GmDataInterface} from \"./GmDataInterface.sol\";\n\ncontract GmData1 is GmDataInterface {\n    function getSvg(uint256 index)\n        external\n        pure\n        returns (GmDataSet memory data)\n    {\n        // AUTOGEN:START\n\n    if (index == 0) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373634525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303632565748a954b055373453b74bcfb5d1074bd90169a0197600\";\n      data.compressedSize = 74;\n      data.imageName = \"Mnemonic\";\n    }\n    \n    if (index == 1) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373634525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303630565748a954b055373453b733335753ae3030307034b0367381336df4c1caed8034d05c3b00\";\n      data.compressedSize = 94;\n      data.imageName = \"Hex\";\n    }\n    \n    if (index == 2) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373634525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303231565748a954b055373453b73330343400624335e50a03030347036b900008c1056cf4c15aed8034d00e3b00\";\n      data.compressedSize = 106;\n      data.imageName = \"Binary\";\n    }\n    \n    if (index == 3) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373634525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a930b2b4505748a954b055373453b75353ae30323234b246a20d0c0c8c5ca10c47036bec2a801236fa6033ed8034d0723b00\";\n      data.compressedSize = 131;\n      data.imageName = \"Morse\";\n    }\n    \n    if (index == 4) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b2b0505748ce492c2eb6554f4a2c4e55b7b329292e48cc03a930b234565748a954b055373453b75356565653ae3030307034b04666dbe88335e0d687d045967e244dd84c22de1d48fa8961c0cdd30785981d00\";\n      data.compressedSize = 312;\n      data.imageName = \"3x5\";\n    }\n    \n    if (index == 5) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b234535748ce492c2eb6554f4a2c4e55b7b329292e48cc03a930b230565748a954b055373453b75353ae3030303072b386308c5dac6b202c47036b4cb918741650958d3ed8689c36c46031193f8b1c13c963c06dd207859f1d00\";\n      data.compressedSize = 326;\n      data.imageName = \"Madrid\";\n    }\n    \n    if (index == 6) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b234535748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b3505748a954b055373453b75353ae3030307034b086308c5c410c23234323fc02e4ebb1d107bb8480838c2c103ad2b1da0762985b63aace25a89a6847001526a01b6281ee7b640669aae18ed007459e1d00\";\n      data.compressedSize = 451;\n      data.imageName = \"Heart Left\";\n    }\n    \n    if (index == 7) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b2b0505748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303203caa5542ad8aa1b9aa9dba92957181818381a58c703018463e46c8d248a450c2e64a30f369580e1461620bd4646864650338cdcb01986a1b82606aebc06ae9e382b4106c7c4c723b4616192e87e8866e219e4e942f6a13e284eed00\";\n      data.compressedSize = 474;\n      data.imageName = \"ASCII New Roman\";\n    }\n    \n    if (index == 8) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c5058979201546e616ea0a29950ab6ea8666ea76f96aca1546468646d6301a24606060e068600d97f2c794b3d1079b87d3d81ab84a38a386481621a3315cec8fe262dc2c4206633a198bebc86390eca77c6a59a80f4a187600\";\n      data.compressedSize = 543;\n      data.imageName = \"Tinker-Toy\";\n    }\n    \n    if (index == 9) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b2b0505748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303233565748a954b055373453b75353ae3030307034b08633e2e331c5d01846ce40553075400e5cda461f6c0d4edb605a2cac612c37b87d4026ba35c488008d22642bc26b084b09fa916c0671ae01ba1b979768ca80bb4e1f9462ec00\";\n      data.compressedSize = 568;\n      data.imageName = \"JS Cursive\";\n    }\n    \n    if (index == 10) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c505897920154646c6ea0a29950ab6ea8666ea766aca150606068e06d6b81846aed689be401000174ff1858224b8908d3ed878126c4981196864644dd00d68eab1b2497105b2265f1c86e162136d1bc295ae44198cd512a26d0bf3f5c516a2e4598669ab3e287dd90100\";\n      data.compressedSize = 614;\n      data.imageName = \"Rowan Cap\";\n    }\n    \n    if (index == 11) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c5058979201546c6c6ea0a29950ab6ea8666ea766aca150606068e06d6e96000e7e6e662672271e00c1b7db0e138ed4032169381622716c3098811b61bdd5fd4b7038fefe8ee5fd4f824c9655467c0ddaa0f4a9d7600\";\n      data.compressedSize = 676;\n      data.imageName = \"Letters\";\n    }\n    \n    if (index == 12) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c505897920154626c6ea0a29950ab6ea8666ea766aca150606068e06d6988cf87804131b0b99198fa9dd461f6c25c9361bb921392101ceac4157668ee496042cee8b21dd2518765858c7d76091259a457a18c4c082d2c819215883ec0a5436e936d4c0630b39a469c780bb501f9446ed00\";\n      data.compressedSize = 682;\n      data.imageName = \"Standard\";\n    }\n    \n    if (index == 13) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c5058979201546c616ea0a29950ab6ea8666ea766aca150606068e06d6c430e249524da94136fa603793e374a8f946160821cdf878f23510ed94f81ad2c2a186640dc43905e81184ebdd71863b42198a065f223490154135d8c3b986a002b855faa0846e0700\";\n      data.compressedSize = 751;\n      data.imageName = \"Puzzle\";\n    }\n    \n    if (index == 14) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c505897920154626c6ea0a29950ab6ea8666ea766aca150606068e06d6988c782040e1a0f0e06c1b7db0d124db60e4866c159c99805f16891d43a2cdc846c245e2f1c8d14e846897c7c0fc6be44ca2e3499423ce4520bdf0b8c7349aa60cb80bf54169dd0e00\";\n      data.compressedSize = 754;\n      data.imageName = \"Slant\";\n    }\n    \n    if (index == 15) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c5058979201546c6c6ea0a29950ab6ea8666ea76f110a0a65c616060e068608d850f67dbe8830dc163165c29927e383301c23272b326a00e891d43d04e4ca3d0ad01b270ca61d5472d11826e8f81f9d4c8992803e3a92747c86d08bdf0148069349d197037eb8352bb1d00\";\n      data.compressedSize = 756;\n      data.imageName = \"Speed\";\n    }\n    \n    if (index == 16) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c50589792015462616ea0a29950ab6ea8666ea766aca150606068e06d670467c3c8469e46c8d45925c2138c3461fec12621d64e486c58c1a3c8a6a481122cb6131f170f36a4870240e21846124860c2603e1203c8aa8c8a0c0c13103e3507d5036b10300\";\n      data.compressedSize = 813;\n      data.imageName = \"Script\";\n    }\n    \n    if (index == 17) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b1505748a954b055373453b75353ae3030307034b0c664c4c72398789451c8b0d107bb8c64071ab921b93401ceacc1e20f6c3ea286436260e619395b637100ba538cccb1d81a430d87d4c4c35de2668d4d1a0c89b600a6d4c8c89a18460da9ea49f429500b287e8d8c0c8dac0d301868614b92626427e88372901d00\";\n      data.compressedSize = 840;\n      data.imageName = \"Train\";\n    }\n    \n    if (index == 18) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b2505748a954b055373453b75353ae3030307034b04eb5b080b32d8861a7c29970868d3ed8169c96a558906a894512d18647926eb805d186a3f9d5c8c89a7e96216c75b6c694b2b008c0a59ea60c32420cce827b27004d88ce7ec0f48c3e281fd90100\";\n      data.compressedSize = 846;\n      data.imageName = \"Rozzo\";\n    }\n    \n    if (index == 19) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303235565748a954b055373453b75353ae3030303072b506328c8c0c8d48a1e11a2934c1461fec389c6eac71c76707b22b1c0dac6b6a7c49514dd06eb85208c3d811668a9b750c9a10d87634f546163065400d9a14d98b3087087b09a927d57e23735ca1696eed5e438a6a5f827627909992ccadc9d70977933e2827d90100\";\n      data.compressedSize = 848;\n      data.imageName = \"Cards\";\n    }\n    \n    if (index == 20) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303232565748a954b055373453b75353ae3030307034b0c66454c7c7e3978dc7aa14996da30fb696b0ed58edc2652a9220564d846c25e8319ad83a307ec5e351828ea0a52bf0c7c1c032e0bed107e52a3b00\";\n      data.compressedSize = 860;\n      data.imageName = \"Nipples\";\n    }\n    \n    if (index == 21) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303232565748a954b055373453b75353ae3030307034b0c664f86b6ae297d5c4aa14996da30fb696b0ed58edc2652a9220564d846c25e8319ad83a307ec5e351828ea0a52bf0c7c1c032e0bed107e52a3b00\";\n      data.compressedSize = 860;\n      data.imageName = \"Coinstak\";\n    }\n    \n    if (index == 22) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303232565748a954b055373453b75353ae3030307034b0c664f8d7d5e197adc3aa14996da30fb696b0ed58edc2652a9220564d846c25e8319ad83a307ec5e351828ea0a52bf0c7c1c032e0bed107e52a3b00\";\n      data.compressedSize = 860;\n      data.imageName = \"Tubular\";\n    }\n    \n    if (index == 23) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303231565748a954b055373453b75353ae3030307034b0c664c4c7e3914452158f950d67d8e883ad26d605466e3086b935c2b484184c5984b50865d8c4628873819105baef8022f19a70b19a1a4c69b88826517235845c9210832d046bb039878018e97ed644f62b31314f2183e87411034f5658639f0e2ed407e52e3b00\";\n      data.compressedSize = 868;\n      data.imageName = \"Puffy\";\n    }\n    \n    if (index == 24) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b1505748a954b055373453b75353ae3030307034b08e87009c7c1b7db009380daa89812b259e61e4664db63e820e42d7e304621819191a61a3e10a205a28d34cbcd36af078b5062f0baf7a121c904ea4c5b954b270b04606304981137c0c061f6e803e2893d90100\";\n      data.compressedSize = 875;\n      data.imageName = \"Keyboard\";\n    }\n    \n    if (index == 25) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b5505748a954b055373453b75353ae3030307034b086308c2cacd1448891c2cad02446918d3ed85d849da719a3a949bc3b48752b71ce809b0a64c46b6ac6e0f33c4e492373327c8f69bf26924be2b13a8f6c5fba2174c427c0993535783c0267c4a03b90086b63e2611e70b646b22e1e0c49f7454d3cdc3c37d252017949461f94f5ec00\";\n      data.compressedSize = 897;\n      data.imageName = \"Fire Font-k\";\n    }\n    \n    if (index == 26) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b5505748a954b055373453b75353ae3030303072b5ce0f88cc8773200c4703ebfcfcc87c6ce236fa60f3701a6b015789876181ce3232c72689458836d6639724c3fa84c8fcfc00da190f5168ec688d162f5819e836612ac263105629129d07640043032d82316d209b41ba7308061be58ec2e34c7d5056b50300\";\n      data.compressedSize = 945;\n      data.imageName = \"Jazmine\";\n    }\n    \n    if (index == 27) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303236565748a954b055373453b75353ae3030307034b0560603381793815712af721b7db0e538dd409cc9d854117231b5dd409c3b91cc52a69a1bd08cc5ea493a85f9604c07b472135df3873e2817db0100\";\n      data.compressedSize = 972;\n      data.imageName = \"Banner3\";\n    }\n    \n    if (index == 28) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93034b3505748a95400b1d4edd4942b0c0c0c1c0dac8961c4e30136fa601b28b208680c846de4661d839f4548257679b80540cb2870703c293612eb2302fec17405e91ea0387c914571a8c0136c443b189aa4488ad778d2dd43b4c34808350c405206833b441f949fed00\";\n      data.compressedSize = 982;\n      data.imageName = \"Peaks Slant\";\n    }\n    \n    if (index == 29) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b4505748a954b055373453b75353ae3030307034b0c6c3888f8f47b089d280ac351e9f161b7db0bbc8719e1b92250970b60fa6422f342123736cbe4008410d3372a6c49935282c232343236b185d834511367df1354084458274c72082ca273ede0b67c0a0aa44b0b0e9f0a2c0399ab090c09e387cbce2e3b1db0e1427da36af9878a4c467e466ed5683dbd81ad23de10531de8d98fc407506dcb9faa07c6f0700\";\n      data.compressedSize = 1022;\n      data.imageName = \"Henry 3D\";\n    }\n    \n    if (index == 30) {\n      data.compressedImage = hex\"a593dd0a823018866f6510f4e19173860a3a21c2eec03361587916114c4161179f8a7f6dd356ede8ddf7fb385ea3b2a84b5453c0801a0ac43b00bade73ce295c725e401c95fc993fba0ae2ba806e0da2e07810ef7735c6f8884355b0f66ca4177566b14944760fb3ca944a2de43c0ad241892a15c3dd9f876652eddced87a232de9d89a954683e4b255b36cc0cca9425d727060d81609b5cbf278d59e687ee7ca15b631cfc7e27b386570cda896bce724fb220bd20c4216f016d2609ff70ac6c8ba0f5a9c5466a75645b20ad557dbbf074125a1b4c76f7efc72f\";\n      data.compressedSize = 1026;\n      data.imageName = \"Dancing Font\";\n    }\n    \n    if (index == 31) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303232565748a954b055373453b75353ae3030307034b0c6c53072b38e8b234e551c115a51c56cf4c1ce22d67578dd42d8362c92780d23ce752404d000b86e70871d9e0023c191f4772571713e500cb8aff441a5821d00\";\n      data.compressedSize = 1052;\n      data.imageName = \"Peaks\";\n    }\n    \n    if (index == 32) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b2505748a954b055373453b75353ae3030307034b0c664c4c7e391c4a63c1e2b1b0fc3461fec2a621d67e40663985b23cc4f88c1a30cc94509c8ec18721d03341ca137c607898d4d9e3431221c81a4271e399091c571b2890e6e841b817660f5633cba2f088a9118d7980c90b9083fc32399c8d4491e830247c7c42305223ddd8ce9787d50e1600700\";\n      data.compressedSize = 1059;\n      data.imageName = \"Larry 3D\";\n    }\n    \n    if (index == 33) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a93032b4505748a954b055373453b78b8f5753ae3030307034b0268f114fb109f80cb7d107bb1ba7f331b5686275623c16e11a6ab912611089ce3572c3692c5629bc418dc53b353170c36a2877b691056ed7922815439cf34914223af4b1581f83358968d2d379585d403c0318d0f1f1d81c804314ee1c7d50d9610700\";\n      data.compressedSize = 1090;\n      data.imageName = \"Goofy\";\n    }\n    \n    if (index == 34) {\n      data.compressedImage = hex\"ad54cf0b823014fe570641efd87a4a0a738248dd842e1d6497d4bc45067ad0ffbe19f5322d5dd263876fdbf77e7d6fccabf2ba62b5040eac91800e02cbce49594a48933207dfabca6b726919c82d60a78649586fc05f2e6ace79c0450fe0f609c21620aef17160053f00dc89c90cc3ab7980927ee478abbb021342e86e45af5f74c4511b6d46728837cdcc7b24c75f0a564a8d845477a3217436e16010e1976b43c94828fb05b21933fe18a8cfb1ff04709a63ac80261e63372dfac3ef80c275f572891f3f3115a20f35a130ce3804af271a47873d858fa3d686f468f2456b67ed4915adda3fc6bf01\";\n      data.compressedSize = 1130;\n      data.imageName = \"Cosmike\";\n    }\n    \n    if (index == 35) {\n      data.compressedImage = hex\"ad544b0a833010bd4aa0d0212be32caa102388e82984d4b6ee4a29c485debed8d2688d4953edee31df376f2649daa66b49278001e905608440ced75a2901a75a359026adbad7b72102310672e98980f000e97ed731c632c64d40ab17c462b02186c8a7065b9a91efed4c8227495fae98bf41c4175d53ca3997d4460763eb18baf4d8ac34624abe76165767a7c852bab4f5d9ce5702bf2c845a652bb81c376dac60b17da57dd5dcf65f85f3adfa6870d4d3529fe3a0ab15d6e53e149e5d8cf91e36826933872e7a9860f88dd207\";\n      data.compressedSize = 1172;\n      data.imageName = \"Ghoulish\";\n    }\n    \n    if (index == 36) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c505897920154646c6ea0a29950ab6ea8666ea766aca150606068e06d6680c13ca18543710bf5d36fa60ef11eb4b2343121c4e1203d340b85d94aba1d89778ecc1a3d8c480b02e4c9331a58831c784e4b8347624ec164c06a662b83924a9218681d51c127d89e95d4cb7102385c799e4790ebf76b82ff541e5931d00\";\n      data.compressedSize = 1190;\n      data.imageName = \"S Blood\";\n    }\n    \n    if (index == 37) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b45537b200d2c93989c5c5b6ea4989c5a9ea763625c505897920154646c6ea0a29950ab6ea8666ea766aca150606068e06d61086b1236e860b090cb881543719ab5d36fa60ef51c197980e2789418cc9c4041b5635a4fa925c7b28d135287d89259ea8e403a2d204157c495e8411952fe9e24b7d50f9640700\";\n      data.compressedSize = 1190;\n      data.imageName = \"USA Flag\";\n    }\n    \n    if (index == 38) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303232565748a954b055373453b75353ae3030307034b0c66444435846aed6680cd254236b8b2653ce461fec7cc2be20cacde4ba02a722028613723d95027a805c3fb4c31e4f4053c9f103e30bd2d2d4c032e0bed30795627600\";\n      data.compressedSize = 1228;\n      data.imageName = \"Tiles\";\n    }\n    \n    if (index == 39) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a930b4b0505748a95400b2ccd4edd4942b0c0c0c1c0dac210c2357eb7c2880cbc0d940496cca714992a80ac8b0d107bb12a7632d2c2ca0c698233425585824611a0514b508802a36b28e04aa41e551603956a7d3599690634181929f020f0173ebc1e538e414863549e4030dce278a47c8b21478b4e3f1062623d28524e5838441283090b300520631b71ed29ed507157e7600\";\n      data.compressedSize = 1283;\n      data.imageName = \"Roman\";\n    }\n    \n    if (index == 40) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303232565748a954b055373453b75353ae3030307034b0c6c5307685319cd119e4e9c2d44e8c15f8d5d8e883bd47ac2f49f213e5ae23a898484b89f325d5236c50fa7264c4259e08a3bae706932fc94bc303c580fb521f540adb0100\";\n      data.compressedSize = 1420;\n      data.imageName = \"Barbwire\";\n    }\n    \n    if (index == 41) {\n      data.compressedImage = hex\"bd94cd0a83300cc75fa53058f0648d4c053f6088bbfa0203759bb731067a50e8c36f6ea3d4aed52273a786364d7ef9276dd4d65d4bba1828903e06dc7940ced7aa696238554d0d49d436f7ea36782006402e3d89c1f120d96e3a4ae99e862b196e3a18880e7e3630935d30084bc9c70fadef8091fdaae107a5bc1984846eb6b0c8232f21cff9a6552c65c6915af23aa395fab228391ef49228fa6499d13f098c8596846213d29632bc3fd50836c7aa48c5666953a1d3fa009c4c64652b317ee70ac282b7d720c2ccd91248116d3c9a5329ffc03a1a26ddb352bd185f3390a6be069738bb3dfcddc903\";\n      data.compressedSize = 1474;\n      data.imageName = \"Lil Devil\";\n    }\n    \n    if (index == 42) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373233515748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303236565748a954b055373453b75353ae3030307034b04663183992c0c0d44e53868d3ed833c4fa098bc3dd7033707b8ea4202135fc88f31331ce44b8d78d9400a0811a52fde4466920921097e4aa2135edb991c2181a7ea2561941d3b8a4653ce1cb6a642926520ddc4ffaa0d2de0e00\";\n      data.compressedSize = 1524;\n      data.imageName = \"3-D\";\n    }\n    \n    if (index == 43) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b455373237525748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303234565748a954b055373453b75353ae3030307034b0c6c5307685315cd045f0e8c2a7dd05a78178ecc2670e36f7d8e8833d4cacbf49f2253d14936b2071fe262f5287bebf476a7c139353a9e6dd41ed6f0a8bb30167c0fdad0f2af1ed00\";\n      data.compressedSize = 1528;\n      data.imageName = \"Arrows\";\n    }\n    \n    if (index == 44) {\n      data.compressedImage = hex\"ad55d10a022110fc1561a17d3cb3388254b8fec4eade22027df0febeac3888335d4f7d5a74677667e641e946ef9857c8914d0a45bf4776b9196b159e8d1d514b671fe61e3a043f20bb4e4ce1b647bd01cf391ff8f153ec8636c54c58c4bc44d5f3c8eead3c63c00c15a7aaa512f0e513e586322271433620cdd1a4a08c2815d7ce80171456244f140e594f8b0288339293067ac23fddb0465803ab72c2fe6f182d62ed851485ecb46402f87b22b450bd184416eac2c7a19f\";\n      data.compressedSize = 1599;\n      data.imageName = \"Alligator2\";\n    }\n    \n    if (index == 45) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b4553732b1505748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303432565748a95400b2ccd4ede2090235e50a03030347036b0a1936fa6027e074095c21cd9d44b44b909d04611bb959c74001359d46ba8b909c86ec32381b0f03ea76540f61f2e3e9e503845762b03a36068b03f17b8f907c3cbd7c84144b44450d0167c7e0e0a1466d0cb15ea5aa0fb12748709ec0743a7e2ebd5c4a54c28b27cfe93476311513169c118fdf2c4aa5e121a20faaabec00\";\n      data.compressedSize = 1714;\n      data.imageName = \"Slant Relief\";\n    }\n    \n    if (index == 46) {\n      data.compressedImage = hex\"b32949ad2851a8b055375057a8b4553732b1505748ce492c2eb6554f4a2c4e55b7b329292e48cc03a9303234565748a954b055373453b75353ae3030307034b086308c4c4863c4a0e9a7d420926db3d1077b8c80ff304d4336233e9eb055044c2053510cf5fc61e4664d7c5c00a56ac8309172c53514f8b3866afeab21c1000afd13435e7618b4fe81ab8c898f8fc797ec6b800a6a9055a372484f07388b1ad2bc4d67064dd307b24583dc9fa8e9069e72dcac07d6d998eed707d5a47600\";\n      data.compressedSize = 1872;\n      data.imageName = \"Big Money-nw\";\n    }\n    \n    if (index == 47) {\n      data.compressedImage = hex\"b555c90a833010fd9540a1434ec6b434820bf4a03df5030a426a5b6fa514f4a0e0c757a5c65de3761b667933f3e6198dd08f4214994000c526d0a306e8f9f682c0848717f8601961f0f53e5906250740af1899a09ec0daef2242c899e86d830fc496666fd0c450f215276f4a35fd89ffa69df92855a95e75d49364465d8239778fb2b9d3f2d80573a2791a73e75d6cbd26d29b72ee0aca84f3262c2c46e21d0299532c37590ac8fb8e5cd0435933c2724eea82e0787dc4053a4a12615eba9c938c4add550e4c5e17cd2f8a9520f716494dbdb296703b9e9a35b1a55535fa72381d23b8fd55783b64e95b8d72366cc8946fd7426ca964ff59eb07\";\n      data.compressedSize = 1902;\n      data.imageName = \"Bear\";\n    }\n    \n    if (index == 48) {\n      data.compressedImage = hex\"c5555d0b823014fd2b83a08b4fce154df00342ead53f104c2bdf22027d50f0c7a7416bda9c1b8d7cf232ef3d3be7ec4cc3aaa82b54478001351190ad0fe872cbcb3282735e16108755f9c8ef7d07f13680ae0d8ac0db41bc5ed518e33d0efe50b0d92672e80b423cf25ea081a3031dba2f7dcbcb24fed70a1d881bf5a4292f1d664f17494423a79e22292d71c90f28aa61c75027f7542742dcf6a32a5cad42403646a22ab9adf9e949366f99242c43fe7d665aeb39b6445f792ce221249fa1d33490e41651f5be7aec3b7b75d8d3c9a077008ce74b036ae69d1df745d632cfa992cc222a06976deec3a5ab2933e83519e2aadcfebf1b3f01\";\n      data.compressedSize = 1918;\n      data.imageName = \"Ghost\";\n    }\n    \n    if (index == 49) {\n      data.compressedImage = hex\"d555410a833010fc4aa0d03d9aa6902a1aa1941ef7019eaca9bd95528807fd7d9b6243c45423e4606f9bcd647626ec2659736b1bd20aa0403a016ccf805cef95520264a56e90678d7a560f8d603406527744c08e43beddb494d2234d4d5096e3dc4450baf07e1c93a82cfa289e17ce1125229af5c58af5de98da9d9d2bc87b5a767897903efe107962cb1aaca47761cb8f45ed27c0480e86f2105c7c09cffd71764a3159223830cabb970af4d3b90ec12c4e7191da75dfbc994ad337fa8d4074bd2f3fb3be533ceda090a1ee3578b078f89c2c75f2b706872db35e1f634391fea4f317\";\n      data.compressedSize = 1963;\n      data.imageName = \"Georgi16\";\n    }\n    \n// AUTOGEN:END\n        return data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}